<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hard Bass Club — Multi‑Layer Bass Engine</title>
<style>
:root{--bg:#06060a;--panel:#0f1116;--accent:#00ffb3;--accent2:#ff2d92}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Arial;color:#e6edf3;background:linear-gradient(180deg,#050507 0%, #0b0b10 60%);} 
.wrap{max-width:1200px;margin:20px auto;padding:20px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;}
header{display:flex;gap:16px;align-items:center}
h1{margin:0;font-size:20px}
.sub{opacity:0.75;font-size:13px}
.controls{display:flex;gap:12px;flex-wrap:wrap;margin-top:14px}
.btn{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#050505;padding:10px 14px;border-radius:10px;border:0;font-weight:700;cursor:pointer}
.secondary{background:#111218;color:#c7d0df;padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
.panel{margin-top:16px;padding:12px;border-radius:10px;background:rgba(255,255,255,0.02)}
.row{display:flex;gap:12px;align-items:center}
.col{display:flex;flex-direction:column;gap:8px}
label{font-size:13px;color:#c7d0df}
input[type=range]{-webkit-appearance:none;height:6px;background:linear-gradient(90deg,#20232a,#111218);border-radius:6px;outline:none}
#visual{width:100%;height:320px;margin-top:18px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
small{color:#9fb0c7}
.footer{margin-top:12px;color:#b9cad8}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Hard Bass Club — Multi‑Layer Bass Engine</h1>
      <div class="sub">Engine tạo nhiều lớp bass & biến thể (seeded / procedural). Nghe "cháy" liên tục — không lặp nhàm chán.</div>
    </div>
  </header>

  <div class="controls">
    <button id="playBtn" class="btn">Play</button>
    <button id="stopBtn" class="secondary">Stop</button>

    <div class="row">
      <label for="bpm">BPM</label>
      <input id="bpm" type="range" min="100" max="150" value="132" style="width:160px">
      <small id="bpmVal">132</small>
    </div>

    <div class="row">
      <label>Master</label>
      <input id="master" type="range" min="0" max="1" step="0.01" value="0.85" style="width:140px">
    </div>

    <div class="row">
      <label>Variation Intensity</label>
      <input id="varInt" type="range" min="0" max="1" step="0.01" value="0.85" style="width:140px">
    </div>

    <div class="row">
      <label>Density (voices)</label>
      <input id="density" type="range" min="1" max="12" step="1" value="8" style="width:140px">
    </div>

  </div>

  <div class="panel">
    <div style="display:flex;gap:12px;flex-wrap:wrap">
      <div class="col" style="flex:1">
        <label><input id="layerSub" type="checkbox" checked> Sub Bass</label>
        <label><input id="layerMid" type="checkbox" checked> Mid Bass</label>
        <label><input id="layerDist" type="checkbox" checked> Distorted Bass</label>
      </div>
      <div class="col" style="flex:1">
        <label><input id="layerReece" type="checkbox" checked> Reese / Detuned Bass</label>
        <label><input id="layerNoise" type="checkbox" checked> Noise / Percussive Bass</label>
        <label><input id="autoFilter" type="checkbox" checked> Global Auto‑Filter</label>
      </div>
      <div style="flex:1">
        <small>Tip: tăng Density để có nhiều layer/voices; tăng Variation Intensity để random mạnh thông số (filter, pitch, detune).</small>
      </div>
    </div>
  </div>

  <canvas id="visual"></canvas>

  <div class="footer">Generated live in your browser using the Web Audio API — procedural seeds create thousands of perceptual variations. You can let it play for 30+ minutes.</div>
</div>

<script>
// Multi-layer bass engine
(() => {
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let ctx = null;
  let masterGain, analyser;
  let isPlaying = false;
  let schedulerId = null;

  const playBtn = document.getElementById('playBtn');
  const stopBtn = document.getElementById('stopBtn');
  const bpmSlider = document.getElementById('bpm');
  const bpmVal = document.getElementById('bpmVal');
  const masterSlider = document.getElementById('master');
  const varInt = document.getElementById('varInt');
  const density = document.getElementById('density');
  const canvas = document.getElementById('visual');
  const ctx2 = canvas.getContext('2d');

  const layerSub = document.getElementById('layerSub');
  const layerMid = document.getElementById('layerMid');
  const layerDist = document.getElementById('layerDist');
  const layerReece = document.getElementById('layerReece');
  const layerNoise = document.getElementById('layerNoise');
  const autoFilter = document.getElementById('autoFilter');

  function resize(){ canvas.width = canvas.clientWidth * devicePixelRatio; canvas.height = canvas.clientHeight * devicePixelRatio; }
  window.addEventListener('resize', resize); resize();

  bpmSlider.addEventListener('input', ()=>{ bpmVal.textContent = bpmSlider.value; });
  masterSlider.addEventListener('input', ()=>{ if(masterGain) masterGain.gain.value = masterSlider.value; });

  function ensureAudio(){
    if(!ctx){
      ctx = new AudioContext();
      masterGain = ctx.createGain(); masterGain.gain.value = masterSlider.value;
      analyser = ctx.createAnalyser(); analyser.fftSize = 2048;
      // final chain: master -> analyser -> destination
      masterGain.connect(analyser);
      analyser.connect(ctx.destination);
    }
  }

  // Utility seeded RNG to produce repeatable variations
  function makeSeededRng(seed){
    let s = seed >>> 0;
    return () => { s = (s * 1664525 + 1013904223) >>> 0; return s / 4294967296; };
  }

  // Create common effects node factory
  function makeFilter(type, freq, q=1){ const f = ctx.createBiquadFilter(); f.type = type; f.frequency.value = freq; f.Q.value = q; return f; }
  function makeDistortion(amount=20){ const wave = ctx.createWaveShaper(); const k = typeof amount === 'number' ? amount : 50; const n = 44100; const curve = new Float32Array(n); const deg = Math.PI/180; for(let i=0;i<n;i++){ const x = i*2/n -1; curve[i] = (3 + k) * x * 20*deg / (Math.PI + k * Math.abs(x)); } wave.curve = curve; return wave; }

  // Voice generators
  function subBassVoice(time, dur, noteFreq, seed){
    if(!layerSub.checked) return;
    const rng = makeSeededRng(seed);
    const osc = ctx.createOscillator(); osc.type = 'sine';
    const gain = ctx.createGain(); gain.gain.setValueAtTime(0.0001, time);
    const envAttack = 0.005 + rng()*0.02 * (1 - varInt.value);
    const envDecay = dur * (0.6 + rng()*0.6);
    gain.gain.linearRampToValueAtTime(1.0, time + envAttack);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + envDecay);
    osc.frequency.value = noteFreq * (1 + (rng()-0.5)*0.004);
    const lp = makeFilter('lowpass', 120 + rng()*40, 0.8 + rng()*1.2);
    osc.connect(lp); lp.connect(gain); gain.connect(masterGain);
    osc.start(time); osc.stop(time + dur + 0.05);
  }

  function midBassVoice(time, dur, noteFreq, seed){
    if(!layerMid.checked) return;
    const rng = makeSeededRng(seed+1);
    const osc = ctx.createOscillator(); osc.type = (rng()>0.6)?'sawtooth':'triangle';
    const gain = ctx.createGain(); gain.gain.setValueAtTime(0.0001, time);
    const env = 0.02 + rng()*0.06;
    gain.gain.linearRampToValueAtTime(0.9 * (0.6 + rng()*0.8), time + env);
    gain.gain.linearRampToValueAtTime(0.0001, time + dur);
    osc.detune.value = (rng()-0.5)*30 * (varInt.value);
    const hp = makeFilter('highpass', 60 + rng()*30, 0.7);
    const lp = makeFilter('lowpass', 800 + rng()*800, 1.0 + rng()*2.0);
    osc.connect(hp); hp.connect(lp); lp.connect(gain); gain.connect(masterGain);
    osc.start(time); osc.stop(time + dur + 0.05);
  }

  function reeceVoice(time, dur, noteFreq, seed){
    if(!layerReece.checked) return;
    const rng = makeSeededRng(seed+2);
    // create two detuned saws
    const o1 = ctx.createOscillator(); o1.type='sawtooth';
    const o2 = ctx.createOscillator(); o2.type='sawtooth';
    o1.frequency.value = noteFreq * (1 + (rng()-0.5)*0.002);
    o2.frequency.value = noteFreq * (1 + (rng()-0.5)*0.006);
    o1.detune.value = (rng()-0.5)*40 * varInt.value;
    o2.detune.value = (rng()-0.5)*60 * varInt.value;
    const mix = ctx.createGain(); mix.gain.value = 0.6;
    const bp = makeFilter('bandpass', 120 + rng()*200, 0.7 + rng()*1.5);
    const gain = ctx.createGain(); gain.gain.setValueAtTime(0.0001, time);
    gain.gain.linearRampToValueAtTime(0.85 * (0.6 + rng()*0.8), time + 0.01);
    gain.gain.linearRampToValueAtTime(0.0001, time + dur);
    o1.connect(mix); o2.connect(mix); mix.connect(bp); bp.connect(gain); gain.connect(masterGain);
    o1.start(time); o2.start(time); o1.stop(time + dur + 0.05); o2.stop(time + dur + 0.05);
  }

  function distBassVoice(time, dur, noteFreq, seed){
    if(!layerDist.checked) return;
    const rng = makeSeededRng(seed+3);
    const osc = ctx.createOscillator(); osc.type = (rng()>0.5)?'sawtooth':'square';
    osc.frequency.value = noteFreq * (1 + (rng()-0.5)*0.01);
    const sh = makeDistortion(10 + rng()*30);
    const hp = makeFilter('highpass', 60 + rng()*80, 0.6);
    const gain = ctx.createGain(); gain.gain.setValueAtTime(0.0001, time);
    gain.gain.linearRampToValueAtTime(0.7 + rng()*0.8, time + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, time + dur);
    osc.connect(sh); sh.connect(hp); hp.connect(gain); gain.connect(masterGain);
    osc.start(time); osc.stop(time + dur + 0.05);
  }

  function noiseBassVoice(time, dur, noteFreq, seed){
    if(!layerNoise.checked) return;
    const rng = makeSeededRng(seed+4);
    const bufferSize = Math.floor(0.05 * ctx.sampleRate);
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<bufferSize;i++){ data[i] = (Math.random()*2-1) * Math.exp(-i/(bufferSize*0.02)); }
    const src = ctx.createBufferSource(); src.buffer = buffer;
    const gain = ctx.createGain(); gain.gain.value = 0.08 + rng()*0.12;
    const filt = makeFilter('bandpass', 300 + rng()*1200, 1.0);
    src.connect(filt); filt.connect(gain); gain.connect(masterGain);
    src.start(time); src.stop(time + 0.06 + rng()*0.12);
  }

  // Play scheduler that creates many variations
  let globalStep = 0;
  function startEngine(){
    ensureAudio();
    if(ctx.state === 'suspended') ctx.resume();
    const bpm = Number(bpmSlider.value);
    const secPerBeat = 60 / bpm;
    const sixteenth = secPerBeat / 4;
    let nextTime = ctx.currentTime + 0.05;

    function schedule(){
      const now = ctx.currentTime;
      const rng = makeSeededRng(globalStep + Math.floor(now));
      const voices = Number(density.value);
      // We'll generate a note every sixteenth; for fullness, schedule multiple voices
      for(let v=0; v<voices; v++){
        const offset = (v/voices) * (sixteenth * (0.5 + rng()*1.5));
        const seed = (globalStep * 1315423911) ^ (v*2654435761) ^ Math.floor(now*1000);
        // pick a base frequency pattern but drifted
        const baseNotes = [48, 50, 45, 52, 55, 43]; // MIDI note numbers (rough bass pattern)
        const noteIdx = Math.floor(rng()*baseNotes.length);
        const midi = baseNotes[noteIdx] + Math.floor((rng()-0.5)*2);
        const freq = 440 * Math.pow(2, (midi - 69)/12);
        const dur = sixteenth * (0.8 + rng()*3.2); // variable durations

        // Randomly choose which voices to trigger; intensity affects params
        const intensity = Number(varInt.value);
        if(layerSub.checked && rng()>0.1){ subBassVoice(nextTime + offset, dur, freq * (rng()>0.5?0.5:1), seed); }
        if(layerMid.checked && rng()>0.15){ midBassVoice(nextTime + offset, dur*1.2, freq*1.0, seed); }
        if(layerReece.checked && rng()>0.25){ reeceVoice(nextTime + offset, dur*0.9, freq*1.02, seed); }
        if(layerDist.checked && rng()>0.4){ distBassVoice(nextTime + offset, dur*0.6, freq*1.4, seed); }
        if(layerNoise.checked && rng()>0.35){ noiseBassVoice(nextTime + offset, dur*0.2, freq, seed); }

        // occasional micro pitch mod
        if(rng()>0.96){ // rare big glide
          const glideOsc = ctx.createOscillator(); glideOsc.type='sine'; glideOsc.frequency.value = 0.2 + rng()*1.6;
          const glideGain = ctx.createGain(); glideGain.gain.value = 0.002 * intensity;
          glideOsc.connect(glideGain); glideGain.connect(masterGain);
          glideOsc.start(nextTime + offset); glideOsc.stop(nextTime + offset + 0.1);
        }
      }

      globalStep++;
      nextTime += sixteenth;
    }

    // run at resolution
    const lookahead = 0.05; // seconds
    schedulerId = setInterval(schedule, lookahead*1000);
    animate();
  }

  function stopEngine(){ if(schedulerId){ clearInterval(schedulerId); schedulerId=null; } }

  // Simple visualizer
  const freqData = new Uint8Array(2048);
  function animate(){
    if(!analyser) return;
    requestAnimationFrame(animate);
    analyser.getByteFrequencyData(freqData);
    const w = canvas.width, h = canvas.height;
    ctx2.clearRect(0,0,w,h);
    // background
    ctx2.fillStyle = 'rgba(6,6,10,0.2)'; ctx2.fillRect(0,0,w,h);
    const bars = 100;
    const step = Math.floor(freqData.length / bars);
    for(let i=0;i<bars;i++){
      const v = freqData[i*step]/255;
      const barH = v * h * 0.9;
      const x = i * (w/bars);
      // neon mix
      const r = Math.floor(255 * Math.pow(v,1.1));
      const g = Math.floor(200 * v);
      const b = Math.floor(255 * (1-v));
      ctx2.fillStyle = `rgba(${r},${g},${b},0.95)`;
      ctx2.fillRect(x+2, h-barH, (w/bars)-4, barH);
      ctx2.shadowBlur = 30 * v; ctx2.shadowColor = `rgba(${r},${g},${b},0.6)`;
    }
    ctx2.shadowBlur = 0;
  }

  playBtn.addEventListener('click', async ()=>{
    ensureAudio(); if(ctx.state === 'suspended') await ctx.resume();
    if(!isPlaying){ startEngine(); isPlaying=true; playBtn.textContent='Playing'; }
  });

  stopBtn.addEventListener('click', ()=>{ if(isPlaying){ stopEngine(); isPlaying=false; playBtn.textContent='Play'; } });

  // Unlock audio on first user gesture
  document.body.addEventListener('click', function unlock(){ if(!ctx) ensureAudio(); if(ctx.state === 'suspended') ctx.resume(); document.body.removeEventListener('click', unlock); });

})();
</script>
</body>
</html>
